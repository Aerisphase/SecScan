import numpy as np
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
import requests
from bs4 import BeautifulSoup
import re
from typing import List, Dict, Tuple
import json
from pathlib import Path

class VulnerabilityAnalyzer:
    def __init__(self):
        self.vectorizer = TfidfVectorizer()
        self.vulnerability_db = Path("data/vulnerabilities.json")
        self._load_or_create_db()

    def _load_or_create_db(self):
        """Load or create vulnerability database"""
        if not self.vulnerability_db.exists():
            self.vulnerability_db.parent.mkdir(parents=True, exist_ok=True)
            self._scrape_exploit_db()
        else:
            with open(self.vulnerability_db, 'r', encoding='utf-8') as f:
                self.vulnerabilities = json.load(f)

    def _scrape_exploit_db(self):
        """Scrape vulnerability data from Exploit-DB"""
        base_url = "https://www.exploit-db.com"
        vulnerabilities = []
        
        try:
            # Scrape main exploit listings
            response = requests.get(f"{base_url}/exploits", headers={
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
            })
            soup = BeautifulSoup(response.text, 'html.parser')
            
            # Extract vulnerability data
            for exploit in soup.select('.exploit-list tr'):
                try:
                    title = exploit.select_one('.exploit-title').text.strip()
                    type_ = exploit.select_one('.exploit-type').text.strip()
                    platform = exploit.select_one('.exploit-platform').text.strip()
                    
                    # Get detailed description
                    exploit_url = base_url + exploit.select_one('a')['href']
                    details = self._get_exploit_details(exploit_url)
                    
                    vulnerabilities.append({
                        'title': title,
                        'type': type_,
                        'platform': platform,
                        'description': details.get('description', ''),
                        'recommendations': self._generate_recommendations(type_, details)
                    })
                except Exception as e:
                    print(f"Error processing exploit: {e}")
                    continue
                
            # Save to database
            with open(self.vulnerability_db, 'w', encoding='utf-8') as f:
                json.dump(vulnerabilities, f, ensure_ascii=False, indent=2)
                
            self.vulnerabilities = vulnerabilities
            
        except Exception as e:
            print(f"Error scraping Exploit-DB: {e}")
            # Load fallback data if scraping fails
            self.vulnerabilities = self._get_fallback_data()

    def _get_exploit_details(self, url: str) -> Dict:
        """Get detailed information about an exploit"""
        try:
            response = requests.get(url, headers={
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
            })
            soup = BeautifulSoup(response.text, 'html.parser')
            
            description = soup.select_one('.exploit-description').text.strip()
            code = soup.select_one('.exploit-code').text.strip() if soup.select_one('.exploit-code') else ''
            
            return {
                'description': description,
                'code': code
            }
        except Exception as e:
            print(f"Error getting exploit details: {e}")
            return {}

    def _generate_recommendations(self, vuln_type: str, details: Dict) -> List[str]:
        """Generate recommendations for preventing vulnerabilities"""
        recommendations = []
        
        # Common prevention patterns
        prevention_patterns = {
            'SQL Injection': [
                'Use parameterized queries or prepared statements',
                'Implement input validation and sanitization',
                'Apply the principle of least privilege',
                'Use ORM frameworks with built-in protection',
                'Regularly update database software and patches'
            ],
            'XSS': [
                'Implement Content Security Policy (CSP)',
                'Use output encoding for all user input',
                'Validate and sanitize user input',
                'Use modern frameworks with built-in XSS protection',
                'Set secure cookie attributes'
            ],
            'CSRF': [
                'Implement CSRF tokens',
                'Use SameSite cookie attribute',
                'Verify Origin headers',
                'Implement double-submit cookie pattern',
                'Use secure session management'
            ]
        }
        
        # Get base recommendations based on vulnerability type
        if vuln_type in prevention_patterns:
            recommendations.extend(prevention_patterns[vuln_type])
        
        # Add context-based recommendations
        try:
            # Preprocess the vulnerability details
            text = f"{details.get('description', '')} {details.get('code', '')}"
            
            # Use TF-IDF to analyze the context
            if text.strip():
                text_vector = self.vectorizer.fit_transform([text])
                
                # Add context-specific recommendations
                if 'input' in text.lower():
                    recommendations.append('Implement strict input validation and sanitization')
                if 'database' in text.lower():
                    recommendations.append('Use database access controls and audit logging')
                if 'authentication' in text.lower():
                    recommendations.append('Implement multi-factor authentication')
            
        except Exception as e:
            print(f"Error generating recommendations: {e}")
        
        return recommendations

    def _get_fallback_data(self) -> List[Dict]:
        """Get fallback vulnerability data if scraping fails"""
        return [
            {
                'title': 'SQL Injection Vulnerability',
                'type': 'SQL Injection',
                'platform': 'Web',
                'description': 'Classic SQL injection vulnerability allowing unauthorized database access',
                'recommendations': [
                    'Use parameterized queries or prepared statements',
                    'Implement input validation and sanitization',
                    'Apply the principle of least privilege',
                    'Use ORM frameworks with built-in protection'
                ]
            },
            {
                'title': 'Cross-Site Scripting (XSS)',
                'type': 'XSS',
                'platform': 'Web',
                'description': 'Reflected XSS vulnerability in search functionality',
                'recommendations': [
                    'Implement Content Security Policy (CSP)',
                    'Use output encoding for all user input',
                    'Validate and sanitize user input',
                    'Use modern frameworks with built-in XSS protection'
                ]
            }
        ]

    def get_recommendations(self, vulnerability_type: str, context: str) -> tuple:
        """Get recommendations for a vulnerability."""
        try:
            # Get base recommendations
            recommendations = self._get_base_recommendations(vulnerability_type)
            
            # Get Exploit-DB links for similar vulnerabilities
            exploit_links = self._get_exploit_links(vulnerability_type)
            
            # Combine recommendations with Exploit-DB links
            recommendations.extend(exploit_links)
            
            # Calculate confidence score using TF-IDF similarity
            confidence = self._calculate_confidence(vulnerability_type, context)
            
            return recommendations, confidence
        except Exception as e:
            print(f"Error getting recommendations: {e}")
            return self._get_fallback_recommendations(vulnerability_type)

    def _get_exploit_links(self, vulnerability_type: str) -> list:
        """Get relevant Exploit-DB links for a vulnerability type."""
        try:
            # Map vulnerability types to Exploit-DB search terms
            search_terms = {
                "SQL Injection": "SQL Injection",
                "XSS": "Cross-Site Scripting",
                "CSRF": "Cross-Site Request Forgery",
                "LFI": "File Inclusion",
                "RCE": "Remote Code Execution",
                "XXE": "XML External Entity"
            }
            
            search_term = search_terms.get(vulnerability_type, vulnerability_type)
            search_url = f"https://www.exploit-db.com/search?q={search_term}"
            
            # Return formatted links
            return [
                f"<a href='{search_url}' target='_blank' class='exploit-link'>View similar vulnerabilities on Exploit-DB</a>",
                f"<a href='https://www.exploit-db.com/docs' target='_blank' class='exploit-link'>Read Exploit-DB documentation</a>"
            ]
        except Exception as e:
            print(f"Error getting Exploit-DB links: {e}")
            return []

    def _get_fallback_recommendations(self, vuln_type: str) -> Tuple[List[str], float]:
        """Get fallback recommendations if analysis fails"""
        fallback_data = {
            'SQL Injection': [
                'Use parameterized queries or prepared statements',
                'Implement input validation and sanitization',
                'Apply the principle of least privilege'
            ],
            'XSS': [
                'Implement Content Security Policy (CSP)',
                'Use output encoding for all user input',
                'Validate and sanitize user input'
            ],
            'CSRF': [
                'Implement CSRF tokens',
                'Use SameSite cookie attribute',
                'Verify Origin headers'
            ]
        }
        
        return fallback_data.get(vuln_type, []), 0.5 