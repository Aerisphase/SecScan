import numpy as np
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.ensemble import RandomForestClassifier
import requests
from bs4 import BeautifulSoup
import re
from typing import List, Dict, Tuple, Optional
import json
from pathlib import Path
import joblib
from datetime import datetime, timedelta

class VulnerabilityAnalyzer:
    def __init__(self):
        self.vectorizer = TfidfVectorizer()
        self.classifier = RandomForestClassifier(n_estimators=100)
        self.vulnerability_db = Path("data/vulnerabilities.json")
        self.model_path = Path("data/models")
        self._initialize_models()
        self._load_or_create_db()

    def _initialize_models(self):
        """Initialize ML models for vulnerability analysis"""
        self.model_path.mkdir(parents=True, exist_ok=True)
        
        # Load or create classifier
        classifier_path = self.model_path / "classifier.joblib"
        if classifier_path.exists():
            self.classifier = joblib.load(classifier_path)
        else:
            # Initialize with default parameters
            self.classifier = RandomForestClassifier(n_estimators=100)
            joblib.dump(self.classifier, classifier_path)

    def _load_or_create_db(self):
        """Load or create vulnerability database"""
        if not self.vulnerability_db.exists():
            self.vulnerability_db.parent.mkdir(parents=True, exist_ok=True)
            self._scrape_exploit_db()
        else:
            with open(self.vulnerability_db, 'r', encoding='utf-8') as f:
                self.vulnerabilities = json.load(f)

    def _scrape_exploit_db(self):
        """Scrape vulnerability data from Exploit-DB"""
        base_url = "https://www.exploit-db.com"
        vulnerabilities = []
        
        try:
            # Scrape main exploit listings
            response = requests.get(f"{base_url}/exploits", headers={
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
            })
            soup = BeautifulSoup(response.text, 'html.parser')
            
            # Extract vulnerability data
            for exploit in soup.select('.exploit-list tr'):
                try:
                    title = exploit.select_one('.exploit-title').text.strip()
                    type_ = exploit.select_one('.exploit-type').text.strip()
                    platform = exploit.select_one('.exploit-platform').text.strip()
                    
                    # Get detailed description
                    exploit_url = base_url + exploit.select_one('a')['href']
                    details = self._get_exploit_details(exploit_url)
                    
                    vulnerabilities.append({
                        'title': title,
                        'type': type_,
                        'platform': platform,
                        'description': details.get('description', ''),
                        'code': details.get('code', ''),
                        'recommendations': self._generate_recommendations(type_, details),
                        'risk_score': self._calculate_risk_score(type_, details),
                        'last_updated': datetime.now().isoformat()
                    })
                except Exception as e:
                    print(f"Error processing exploit: {e}")
                    continue
                
            # Save to database
            with open(self.vulnerability_db, 'w', encoding='utf-8') as f:
                json.dump(vulnerabilities, f, ensure_ascii=False, indent=2)
                
            self.vulnerabilities = vulnerabilities
            
        except Exception as e:
            print(f"Error scraping Exploit-DB: {e}")
            self.vulnerabilities = self._get_fallback_data()

    def _get_exploit_details(self, url: str) -> Dict:
        """Get detailed information about an exploit"""
        try:
            response = requests.get(url, headers={
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
            })
            soup = BeautifulSoup(response.text, 'html.parser')
            
            description = soup.select_one('.exploit-description').text.strip()
            code = soup.select_one('.exploit-code').text.strip() if soup.select_one('.exploit-code') else ''
            
            return {
                'description': description,
                'code': code
            }
        except Exception as e:
            print(f"Error getting exploit details: {e}")
            return {}

    def _calculate_risk_score(self, vuln_type: str, details: Dict) -> float:
        """Calculate risk score based on vulnerability type and context"""
        base_scores = {
            'SQL Injection': 0.9,
            'XSS': 0.8,
            'CSRF': 0.7,
            'RCE': 1.0,
            'LFI': 0.8,
            'XXE': 0.7,
            'SSTI': 0.85,
            'Command Injection': 0.95,
            'SSRF': 0.85
        }
        
        # Get base score
        score = base_scores.get(vuln_type, 0.5)
        
        # Adjust based on context
        text = f"{details.get('description', '')} {details.get('code', '')}"
        
        # Increase risk for payment-related contexts
        if any(word in text.lower() for word in ['payment', 'credit card', 'transaction', 'bank']):
            score *= 1.2
            
        # Increase risk for authentication contexts
        if any(word in text.lower() for word in ['login', 'auth', 'password', 'session']):
            score *= 1.1
            
        # Decrease risk for less critical contexts
        if any(word in text.lower() for word in ['blog', 'comment', 'profile']):
            score *= 0.9
            
        return min(1.0, score)

    def _generate_recommendations(self, vuln_type: str, details: Dict) -> List[str]:
        """Generate recommendations for preventing vulnerabilities"""
        recommendations = []
        
        # Common prevention patterns
        prevention_patterns = {
            'SQL Injection': [
                'Use parameterized queries or prepared statements',
                'Implement input validation and sanitization',
                'Apply the principle of least privilege',
                'Use ORM frameworks with built-in protection',
                'Regularly update database software and patches'
            ],
            'XSS': [
                'Implement Content Security Policy (CSP)',
                'Use output encoding for all user input',
                'Validate and sanitize user input',
                'Use modern frameworks with built-in XSS protection',
                'Set secure cookie attributes'
            ],
            'CSRF': [
                'Implement CSRF tokens',
                'Use SameSite cookie attribute',
                'Verify Origin headers',
                'Implement double-submit cookie pattern',
                'Use secure session management'
            ],
            'SSTI': [
                'Use template engines that sandbox execution',
                'Avoid user-controlled template content',
                'Implement input validation and sanitization',
                'Use a template engine with strict context separation',
                'Apply the principle of least privilege for template rendering'
            ],
            'Command Injection': [
                'Avoid using shell commands with user input',
                'Use APIs instead of command-line calls',
                'Implement strict input validation and allowlisting',
                'Run commands with minimal privileges',
                'Use secure coding practices for command execution'
            ],
            'SSRF': [
                'Implement URL allowlisting',
                'Use a dedicated service for remote resource access',
                'Validate and sanitize URL parameters',
                'Restrict access to internal networks',
                'Implement network-level protections'
            ]
        }
        
        # Get base recommendations based on vulnerability type
        if vuln_type in prevention_patterns:
            recommendations.extend(prevention_patterns[vuln_type])
        
        # Add context-based recommendations
        try:
            # Preprocess the vulnerability details
            text = f"{details.get('description', '')} {details.get('code', '')}"
            
            # Use TF-IDF to analyze the context
            if text.strip():
                text_vector = self.vectorizer.fit_transform([text])
                
                # Add context-specific recommendations
                if 'input' in text.lower():
                    recommendations.append('Implement strict input validation and sanitization')
                if 'database' in text.lower():
                    recommendations.append('Use database access controls and audit logging')
                if 'authentication' in text.lower():
                    recommendations.append('Implement multi-factor authentication')
            
        except Exception as e:
            print(f"Error generating recommendations: {e}")
        
        return recommendations

    def _get_fallback_data(self) -> List[Dict]:
        """Get fallback vulnerability data if scraping fails"""
        return [
            {
                'title': 'SQL Injection Vulnerability',
                'type': 'SQL Injection',
                'platform': 'Web',
                'description': 'Classic SQL injection vulnerability allowing unauthorized database access',
                'recommendations': [
                    'Use parameterized queries or prepared statements',
                    'Implement input validation and sanitization',
                    'Apply the principle of least privilege',
                    'Use ORM frameworks with built-in protection'
                ],
                'risk_score': 0.9,
                'last_updated': datetime.now().isoformat()
            },
            {
                'title': 'Cross-Site Scripting (XSS)',
                'type': 'XSS',
                'platform': 'Web',
                'description': 'Reflected XSS vulnerability in search functionality',
                'recommendations': [
                    'Implement Content Security Policy (CSP)',
                    'Use output encoding for all user input',
                    'Validate and sanitize user input',
                    'Use modern frameworks with built-in XSS protection'
                ],
                'risk_score': 0.8,
                'last_updated': datetime.now().isoformat()
            }
        ]

    def analyze_vulnerability(self, vulnerability_type: str, context: str, payload: str) -> Dict:
        """Analyze a vulnerability and provide comprehensive information"""
        try:
            # Get base recommendations
            recommendations = self._get_base_recommendations(vulnerability_type)
            
            # Get Exploit-DB links for similar vulnerabilities
            exploit_links = self._get_exploit_links(vulnerability_type)
            
            # Combine recommendations with Exploit-DB links
            recommendations.extend(exploit_links)
            
            # Calculate risk score
            risk_score = self._calculate_risk_score(vulnerability_type, {'description': context})
            
            # Generate payload variations
            payload_variations = self._generate_payload_variations(payload)
            
            return {
                'type': vulnerability_type,
                'risk_score': risk_score,
                'recommendations': recommendations,
                'payload_variations': payload_variations,
                'confidence': self._calculate_confidence(vulnerability_type, context)
            }
        except Exception as e:
            print(f"Error analyzing vulnerability: {e}")
            return self._get_fallback_analysis(vulnerability_type)

    def _generate_payload_variations(self, payload: str) -> List[str]:
        """Generate variations of a payload to bypass WAF"""
        variations = []
        
        # Basic encoding variations
        variations.append(payload)
        variations.append(payload.replace(' ', '/**/'))
        variations.append(payload.replace(' ', '%20'))
        variations.append(payload.replace(' ', '%09'))
        
        # Case variations
        variations.append(payload.upper())
        variations.append(payload.lower())
        
        # Comment variations
        variations.append(f"/*!{payload}*/")
        variations.append(f"/*{payload}*/")
        
        return variations

    def _calculate_confidence(self, vuln_type: str, context: str) -> float:
        """Calculate confidence score for vulnerability detection"""
        try:
            # Use TF-IDF to compare with known vulnerabilities
            if not hasattr(self, 'vulnerability_vectors'):
                self.vulnerability_vectors = self.vectorizer.fit_transform(
                    [v['description'] for v in self.vulnerabilities]
                )
            
            context_vector = self.vectorizer.transform([context])
            similarities = cosine_similarity(context_vector, self.vulnerability_vectors)
            
            # Get maximum similarity score
            max_similarity = similarities.max()
            
            # Adjust based on vulnerability type
            type_confidence = {
                'SQL Injection': 0.9,
                'XSS': 0.85,
                'CSRF': 0.8,
                'RCE': 0.95,
                'LFI': 0.85,
                'XXE': 0.8,
                'SSTI': 0.87,
                'Command Injection': 0.92,
                'SSRF': 0.88
            }
            
            base_confidence = type_confidence.get(vuln_type, 0.7)
            return min(1.0, base_confidence * (0.5 + 0.5 * max_similarity))
            
        except Exception as e:
            print(f"Error calculating confidence: {e}")
            return 0.5

    def _get_fallback_analysis(self, vuln_type: str) -> Dict:
        """Get fallback analysis if detailed analysis fails"""
        return {
            'type': vuln_type,
            'risk_score': 0.5,
            'recommendations': self._get_fallback_recommendations(vuln_type),
            'payload_variations': [],
            'confidence': 0.5
        }

    def _get_base_recommendations(self, vuln_type: str):
        """Return basic recommendations for a vulnerability type"""
        return self._generate_recommendations(vuln_type, {})

    def _get_fallback_recommendations(self, vuln_type: str):
        """Return fallback recommendations for a vulnerability type"""
        return self._generate_recommendations(vuln_type, {})

    def _get_exploit_links(self, vulnerability_type: str) -> list:
        """Get relevant Exploit-DB links for a vulnerability type."""
        search_terms = {
            "SQL Injection": "SQL Injection",
            "XSS": "Cross-Site Scripting",
            "CSRF": "Cross-Site Request Forgery",
            "LFI": "File Inclusion",
            "RCE": "Remote Code Execution",
            "XXE": "XML External Entity",
            "SSTI": "Server-Side Template Injection",
            "Command Injection": "Command Injection",
            "SSRF": "Server-Side Request Forgery"
        }
        search_term = search_terms.get(vulnerability_type, vulnerability_type)
        search_url = f"https://www.exploit-db.com/search?q={search_term}"
        return [
            f"<a href='{search_url}' target='_blank' class='exploit-link'>View similar vulnerabilities on Exploit-DB</a>",
            f"<a href='https://www.exploit-db.com/docs' target='_blank' class='exploit-link'>Read Exploit-DB documentation</a>"
        ]
    
