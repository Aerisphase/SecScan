[
  {
    "content": "# Cross Site Scripting Prevention Cheat Sheet\n\n## Introduction\n\nThis cheat sheet helps developers prevent XSS vulnerabilities.\n\nCross-Site Scripting (XSS) is a misnomer. Originally this term was derived from early versions of the attack that were primarily focused on stealing data cross-site. Since then, the term has widened to include injection of basically any content. XSS attacks are serious and can lead to account impersonation, observing user behaviour, loading external content, stealing sensitive data, and more.\n\n**This cheatsheet contains techniques to prevent or limit the impact of XSS. Since no single technique will solve XSS, using the right combination of defensive techniques will be necessary to prevent XSS.**\n\n## Framework Security\n\nFortunately, applications built with modern web frameworks have fewer XSS bugs, because these frameworks steer developers towards good security practices and help mitigate XSS by using templating, auto-escaping, and more. However, developers need to know that problems can occur if frameworks are used insecurely, such as:\n\n- _escape hatches_ that frameworks use to directly manipulate the DOM\n- React\u2019s `dangerouslySetInnerHTML` without sanitising the HTML\n- React cannot handle `javascript:` or `data:` URLs without specialized validation\n- Angular\u2019s `bypassSecurityTrustAs*` functions\n- Lit's `unsafeHTML` function\n- Polymer's `inner-h-t-m-l` attribute and `htmlLiteral` function\n- Template injection\n- Out of date framework plugins or components\n- and more\n\nWhen you use a modern web framework, you need to know how your framework prevents XSS and where it has gaps. There will be times where you need to do something outside the protection provided by your framework, which means that Output Encoding and HTML Sanitization can be critical. OWASP will be producing framework specific cheatsheets for React, Vue, and Angular.\n\n## XSS Defense Philosophy\n\nIn order for an XSS attack to be successful, an attacker must be able to insert and execute malicious content in a webpage. Thus, all variables in a web application needs to be protected. Ensuring that **all variables** go through validation and are then escaped or sanitized is known as **perfect injection resistance**. Any variable that does not go through this process is a potential weakness. Frameworks make it easy to ensure variables are correctly validated and escaped or sanitised.\n\nHowever, no framework is perfect and security gaps still exist in popular frameworks like React and Angular. Output encoding and HTML sanitization help address those gaps.\n\n## Output Encoding\n\nWhen you need to safely display data exactly as a user types it in, output encoding is recommended. Variables should not be interpreted as code instead of text. This section covers each form of output encoding, where to use it, and when you should not use dynamic variables at all.\n\nFirst, when you wish to display data as the user typed it in, start with your framework\u2019s default output encoding protection. Automatic encoding and escaping functions are built into most frameworks.\n\nIf you\u2019re not using a framework or need to cover gaps in the framework then you should use an output encoding library. Each variable used in the user interface should be passed through an output encoding function. A list of output encoding libraries is included in the appendix.\n\nThere are many different output encoding methods because browsers parse HTML, JS, URLs, and CSS differently. Using the wrong encoding method may introduce weaknesses or harm the functionality of your application.\n\n### Output Encoding for \u201cHTML Contexts\u201d\n\n\u201cHTML Context\u201d refers to inserting a variable between two basic HTML tags like a `<div>` or `<b>`. For example:\n\n```HTML\n<div> $varUnsafe </div>\n```\n\nAn attacker could modify data that is rendered as `$varUnsafe`. This could lead to an attack being added to a webpage. For example:\n\n```HTML\n<div> <script>alert`1`</script> </div> // Example Attack\n```\n\nIn order to add a variable to a HTML context safely to a web template, use HTML entity encoding for that variable.\n\nHere are some examples of encoded values for specific characters:\n\nIf you're using JavaScript for writing to HTML, look at the `.textContent` attribute. It is a **Safe Sink** and will automatically HTML Entity Encode.\n\n```HTML\n&    &amp;\n<    &lt;\n>    &gt;\n\"    &quot;\n'    &#x27;\n```\n\n### Output Encoding for \u201cHTML Attribute Contexts\u201d\n\n\u201cHTML Attribute Contexts\u201d occur when a variable is placed in an HTML attribute value. You may want to do this to change a hyperlink, hide an element, add alt-text for an image, or change inline CSS styles. You should apply HTML attribute encoding to variables being placed in most HTML attributes. A list of safe HTML attributes is provided in the **Safe Sinks** section.\n\n```HTML\n<div attr=\"$varUnsafe\">\n<div attr=\u201d*x\u201d onblur=\u201dalert(1)*\u201d> // Example Attack\n```\n\n**It\u2019s critical to use quotation marks like `\"` or `'` to surround your variables.** Quoting makes it difficult to change the context a variable operates in, which helps prevent XSS. Quoting also significantly reduces the characterset that you need to encode, making your application more reliable and the encoding easier to implement.\n\nIf you're writing to a HTML Attribute with JavaScript, look at the `.setAttribute` and `[attribute]` methods because they will automatically HTML Attribute Encode. Those are **Safe Sinks** as long as the attribute name is hardcoded and innocuous, like `id` or `class`. Generally, attributes that accept JavaScript, such as `onClick`, are **NOT safe** to use with untrusted attribute values.\n\n### Output Encoding for \u201cJavaScript Contexts\u201d\n\n\u201cJavaScript Contexts\u201d refers to the situation where variables are placed into inline JavaScript and then embedded in an HTML document. This situation commonly occurs in programs that heavily use custom JavaScript that is embedded in their web pages.\n\nHowever, the only \u2018safe\u2019 location for placing variables in JavaScript is inside a \u201cquoted data value\u201d. All other contexts are unsafe and you should not place variable data in them.\n\nExamples of \u201cQuoted Data Values\u201d\n\n```HTML\n<script>alert('$varUnsafe\u2019)</script>\n<script>x=\u2019$varUnsafe\u2019</script>\n<div onmouseover=\"'$varUnsafe'\"</div>\n```\n\nEncode all characters using the `\\xHH` format. Encoding libraries often have a `EncodeForJavaScript` or similar to support this function.\n\nPlease look at the [OWASP Java Encoder JavaScript encoding examples](https://owasp.org/www-project-java-encoder/) for examples of proper JavaScript use that requires minimal encoding.\n\nFor JSON, verify that the `Content-Type` header is `application/json` and not `text/html` to prevent XSS.\n\n### Output Encoding for \u201cCSS Contexts\u201d\n\n\u201cCSS Contexts\u201d refer to variables placed into inline CSS, which is common when developers want their users to customize the look and feel of their webpages. Since CSS is surprisingly powerful, it has been used for many types of attacks. **Variables should only be placed in a CSS property value. Other \u201cCSS Contexts\u201d are unsafe and you should not place variable data in them.**\n\n```HTML\n<style> selector { property : $varUnsafe; } </style>\n<style> selector { property : \"$varUnsafe\"; } </style>\n<span style=\"property : $varUnsafe\">Oh no</span>\n```\n\nIf you're using JavaScript to change a CSS property, look into using\n`style.property = x`.\nThis is a **Safe Sink** and will automatically CSS encode data in it.\n\nWhen inserting variables into CSS properties, ensure the data is properly encoded and sanitized to prevent injection attacks. Avoid placing variables directly into selectors or other CSS contexts.\n\n### Output Encoding for \u201cURL Contexts\u201d\n\n\u201cURL Contexts\u201d refer to variables placed into a URL. Most commonly, a developer will add a parameter or URL fragment to a URL base that is then displayed or used in some operation. Use URL Encoding for these scenarios.\n\n```HTML\n<a href=\"http://www.owasp.org?test=$varUnsafe\">link</a >\n```\n\nEncode all characters with the `%HH` encoding format. Make sure any attributes are fully quoted, same as JS and CSS.\n\n#### Common Mistake\n\nThere will be situations where you use a URL in different contexts. The most common one would be adding it to an `href` or `src` attribute of an `<a>` tag. In these scenarios, you should do URL encoding, followed by HTML attribute encoding.\n\n```HTML\nurl = \"https://site.com?data=\" + urlencode(parameter)\n<a href='attributeEncode(url)'>link</a>\n```\n\nIf you're using JavaScript to construct a URL Query Value, look into using `window.encodeURIComponent(x)`. This is a **Safe Sink** and will automatically URL encode data in it.\n\n### Dangerous Contexts\n\nOutput encoding is not perfect. It will not always prevent XSS. These locations are known as **dangerous contexts**. Dangerous contexts include:\n\n```HTML\n<script>Directly in a script</script>\n<!-- Inside an HTML comment -->\n<style>Directly in CSS</style>\n<div ToDefineAnAttribute=test />\n<ToDefineATag href=\"/test\" />\n```\n\nOther areas to be careful with include:\n\n- Callback functions\n- Where URLs are handled in code such as this CSS { background-url : \u201cjavascript:alert(xss)\u201d; }\n- All JavaScript event handlers (`onclick()`, `onerror()`, `onmouseover()`).\n- Unsafe JS functions like `eval()`, `setInterval()`, `setTimeout()`\n\nDon't place variables into dangerous contexts as even with output encoding, it will not prevent an XSS attack fully.\n\n## HTML Sanitization\n\nWhen users need to author HTML, developers may let users change the styling or structure of content inside a WYSIWYG editor. Output encoding in this case will prevent XSS, but it will break the intended functionality of the application. The styling will not be rendered. In these cases, HTML Sanitization should be used.\n\nHTML Sanitization will strip dangerous HTML from a variable and return a safe string of HTML. OWASP recommends [DOMPurify](https://github.com/cure53/DOMPurify) for HTML Sanitization.\n\n```js\nlet clean = DOMPurify.sanitize(dirty);\n```\n\nThere are some further things to consider:\n\n- If you sanitize content and then modify it afterwards, you can easily void your security efforts.\n- If you sanitize content and then send it to a library for use, check that it doesn\u2019t mutate that string somehow. Otherwise, again, your security efforts are void.\n- You must regularly patch DOMPurify or other HTML Sanitization libraries that you use. Browsers change functionality and bypasses are being discovered regularly.\n\n## Safe Sinks\n\nSecurity professionals often talk in terms of sources and sinks. If you pollute a river, it'll flow downstream somewhere. It\u2019s the same with computer security. XSS sinks are places where variables are placed into your webpage.\n\nThankfully, many sinks where variables can be placed are safe. This is because these sinks treat the variable as text and will never execute it. Try to refactor your code to remove references to unsafe sinks like innerHTML, and instead use textContent or value.\n\n```js\nelem.textContent = dangerVariable;\nelem.insertAdjacentText(dangerVariable);\nelem.className = dangerVariable;\nelem.setAttribute(safeName, dangerVariable);\nformfield.value = dangerVariable;\ndocument.createTextNode(dangerVariable);\ndocument.createElement(dangerVariable);\nelem.innerHTML = DOMPurify.sanitize(dangerVar);\n```\n\n**Safe HTML Attributes include:** `align`, `alink`, `alt`, `bgcolor`, `border`, `cellpadding`, `cellspacing`, `class`, `color`, `cols`, `colspan`, `coords`, `dir`, `face`, `height`, `hspace`, `ismap`, `lang`, `marginheight`, `marginwidth`, `multiple`, `nohref`, `noresize`, `noshade`, `nowrap`, `ref`, `rel`, `rev`, `rows`, `rowspan`, `scrolling`, `shape`, `span`, `summary`, `tabindex`, `title`, `usemap`, `valign`, `value`, `vlink`, `vspace`, `width`.\n\nFor attributes not reported above, ensure that if JavaScript code is provided as a value, it cannot be executed.\n\n## Other Controls\n\nFramework Security Protections, Output Encoding, and HTML Sanitization will provide the best protection for your application. OWASP recommends these in all circumstances.\n\nConsider adopting the following controls in addition to the above.\n\n- Cookie Attributes - These change how JavaScript and browsers can interact with cookies. Cookie attributes try to limit the impact of an XSS attack but don\u2019t prevent the execution of malicious content or address the root cause of the vulnerability.\n- Content Security Policy - An allowlist that prevents content being loaded. It\u2019s easy to make mistakes with the implementation so it should not be your primary defense mechanism. Use a CSP as an additional layer of defense and have a look at the [cheatsheet here](https://cheatsheetseries.owasp.org/cheatsheets/Content_Security_Policy_Cheat_Sheet.html).\n- Web Application Firewalls - These look for known attack strings and block them. WAF\u2019s are unreliable and new bypass techniques are being discovered regularly. WAFs also don\u2019t address the root cause of an XSS vulnerability. In addition, WAFs also miss a class of XSS vulnerabilities that operate exclusively client-side. WAFs are not recommended for preventing XSS, especially DOM-Based XSS.\n\n### XSS Prevention Rules Summary\n\nThese snippets of HTML demonstrate how to render untrusted data safely in a variety of different contexts.\n\nData Type: String\nContext: HTML Body\nCode: `<span>UNTRUSTED DATA </span>`\nSample Defense: HTML Entity Encoding (rule \\#1)\n\nData Type: Strong\nContext: Safe HTML Attributes\nCode: `<input type=\"text\" name=\"fname\" value=\"UNTRUSTED DATA \">`\nSample Defense: Aggressive HTML Entity Encoding (rule \\#2), Only place untrusted data into a list of safe attributes (listed below), Strictly validate unsafe attributes such as background, ID and name.\n\nData Type: String\nContext: GET Parameter\nCode: `<a href=\"/site/search?value=UNTRUSTED DATA \">clickme</a>`\nSample Defense: URL Encoding (rule \\#5).\n\nData Type: String\nContext: Untrusted URL in a SRC or HREF attribute\nCode: `<a href=\"UNTRUSTED URL \">clickme</a> <iframe src=\"UNTRUSTED URL \" />`\nSample Defense: Canonicalize input, URL Validation, Safe URL verification, Allow-list http and HTTPS URLs only (Avoid the JavaScript Protocol to Open a new Window), Attribute encoder.\n\nData Type: String\nContext: CSS Value\nCode: `HTML <div style=\"width: UNTRUSTED DATA ;\">Selection</div>`\nSample Defense: Strict structural validation (rule \\#4), CSS hex encoding, Good design of CSS features.\n\nData Type: String\nContext: JavaScript Variable\nCode: `<script>var currentValue='UNTRUSTED DATA ';</script> <script>someFunction('UNTRUSTED DATA ');</script>`\nSample Defense: Ensure JavaScript variables are quoted, JavaScript hex encoding, JavaScript Unicode encoding, avoid backslash encoding (`\\\"` or `\\'` or `\\\\`).\n\nData Type: HTML\nContext: HTML Body\nCode: `<div>UNTRUSTED HTML</div>`\nSample Defense: HTML validation (JSoup, AntiSamy, HTML Sanitizer...).\n\nData Type: String\nContext: DOM XSS\nCode: `<script>document.write(\"UNTRUSTED INPUT: \" + document.location.hash );<script/>`\nSample Defense: [DOM based XSS Prevention Cheat Sheet](DOM_based_XSS_Prevention_Cheat_Sheet.md) |\n\n### Output Encoding Rules Summary\n\nThe purpose of output encoding (as it relates to Cross Site Scripting) is to convert untrusted input into a safe form where the input is displayed as **data** to the user without executing as **code** in the browser. The following charts provides a list of critical output encoding methods needed to stop Cross Site Scripting.\n\nEncoding Type: HTML Entity\nEncoding Mechanism: Convert `&` to `&amp;`, Convert `<` to `&lt;`, Convert `>` to `&gt;`, Convert `\"` to `&quot;`, Convert `'` to `&#x27`\n\nEncoding Type: HTML Attribute Encoding\nEncoding Mechanism: Encode all characters with the HTML Entity `&#xHH;` format, including spaces, where **HH** represents the hexadecimal value of the character in Unicode. For example, `A` becomes `&#x41`. All alphanumeric characters (letters A to Z, a to z, and digits 0 to 9) remain unencoded.\n\nEncoding Type: URL Encoding\nEncoding Mechanism: Use standard percent encoding, as specified in the [W3C specification](http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4.1), to encode parameter values. Be cautious and only encode parameter values, not the entire URL or path fragments of a URL.\n\nEncoding Type: JavaScript Encoding\nEncoding Mechanism: Encode all characters using the Unicode `\\uXXXX` encoding format, where **XXXX** represents the hexadecimal Unicode code point. For example, `A` becomes `\\u0041`. All alphanumeric characters (letters A to Z, a to z, and digits 0 to 9) remain unencoded.\n\nEncoding Type: CSS Hex Encoding\nEncoding Mechanism: CSS encoding supports both `\\XX` and `\\XXXXXX` formats. To ensure proper encoding, consider these options: (a) Add a space after the CSS encode (which will be ignored by the CSS parser), or (b) use the full six-character CSS encoding format by zero-padding the value. For example, `A` becomes `\\41` (short format) or `\\000041` (full format). Alphanumeric characters (letters A to Z, a to z, and digits 0 to 9) remain unencoded.\n\n## Common Anti-patterns: Ineffective Approaches to Avoid\n\nDefending against XSS is hard. For that reason, some have sought shortcuts to preventing XSS.\n\nWe're going to examine two common [anti-patterns](https://en.wikipedia.org/wiki/Anti-pattern) that frequently show up in ancient posts, but are still commonly cited as solutions in modern posts about XSS defense on programmer forums such as Stack Overflow and other developer hangouts.\n\n### Sole Reliance on Content-Security-Policy (CSP) Headers\n\nFirst, let us be clear, we are a strong proponent of CSP when it is used properly. In the context of XSS defense, CSP works best when it it is:\n\n- Used as a defense-in-depth technique.\n- Customized for each individual application rather than being deployed as a one-size-fits-all enterprise solution.\n\nWhat we are against is a blanket CSP policy for the entire enterprise. Problems with that approach are:\n\n#### Problem 1 - Assumption Browser Versions Support CSP Equally\n\nThere usually is an implicit assumption that all the customer browsers support all the CSP constructs that your blanket CSP policy is using. Furthermore, this assumption often is done without testing the explicitly the `User-Agent` request header to see if it indeed is a supported browser type and rejecting the use of the site if it is not. Why? Because most businesses don't want to turn away customers if they are using an outdated browser that doesn't support some CSP Level 2 or Level 3 construct that they are relying on for XSS prevention.  (Statistically, almost all browsers support CSP Level 1 directives, so unless you are worried about Grandpa pulling out his old Windows 98 laptop and using some ancient version of Internet Explorer to access your site, CSP Level 1 support can probably be assumed.)\n\n#### Problem 2 - Issues Supporting Legacy Applications\n\nMandatory universal enterprise-wide CSP response headers are inevitably going to break some web applications, especially legacy ones. This causes the business to push-back against AppSec guidelines and inevitably results in AppSec issuing waivers and/or security exceptions until the application code can be patched up. But these security exceptions allow cracks in your XSS armor, and even if the cracks are temporary they still can impact your business, at least on a reputational basis.\n\n### Reliance on HTTP Interceptors\n\nThe other common anti-pattern that we have observed is the attempt to deal with validation and/or output encoding in some sort of interceptor such as a Spring Interceptor that generally implements `org.springframework.web.servlet.HandlerInterceptor` or as a JavaEE servlet filter that implements `javax.servlet.Filter`. While this can be successful for very specific applications (for instance, if you validate that all the input requests that are ever rendered are only alphanumeric data), it violates the major tenet of XSS defense where perform output encoding as close to where the data is rendered is possible. Generally, the HTTP request is examined for query and POST parameters but other things HTTP request headers that might be rendered such as cookie data, are not examined. The common approach that we've seen is someone will call either `ESAPI.validator().getValidSafeHTML()` or `ESAPI.encoder.canonicalize()` and depending on the results will redirect to an error page or call something like `ESAPI.encoder().encodeForHTML()`. Aside from the fact that this approach often misses tainted input such as request headers or \"extra path information\" in a URI, the approach completely ignores the fact that the output encoding is completely non-contextual. For example, how does a servlet filter know that an input query parameter is going to be rendered in an HTML context (i.e., between HTML tags) rather than in a JavaScript context such as within a `<script>` tag or used with a JavaScript event handler attribute? It doesn't. And because JavaScript and HTML encoding are not interchangeable, you leave yourself still open to XSS attacks.\n\nUnless your filter or interceptor has full knowledge of your application and specifically an awareness of how your application uses each parameter for a given request, it can't succeed for all the possible edge cases. And we would contend that it never will be able to using this approach because providing that additional required context is way too complex of a design and accidentally introducing some other vulnerability (possibly one whose impact is far worse than XSS) is almost inevitable if you attempt it.\n\nThis naive approach usually has at least one of these four problems.\n\n#### Problem 1 - Encoding for specific context not satisfactory for all URI paths\n\nOne problem is the improper encoding that can still allow exploitable XSS in some URI paths of your application. An example might be a 'lastname' form parameter from a POST that normally is displayed between HTML tags so that HTML encoding is sufficient, but there may be an edge case or two where lastname is actually rendered as part of a JavaScript block where the HTML encoding is not sufficient and thus it is vulnerable to XSS attacks.\n\n#### Problem 2 - Interceptor approach can lead to broken rendering caused by improper or double encoding\n\nA second problem with this approach can be the application can result in incorrect or double encoding. E.g., suppose in the previous example, a developer has done proper output encoding for the JavaScript rendering of lastname. But if it is already been HTML output encoded too, when it is rendered, a legitimate last name like \"O'Hara\" might come out rendered like \"O\\&#39;Hara\".\n\nWhile this second case is not strictly a security problem, if it happens often enough, it can result in business push-back against the use of the filter and thus the business may decide on disabling the filter or a way to specify exceptions for certain pages or parameters being filtered, which in turn will weaken any XSS defense that it was providing.\n\n#### Problem 3 - Interceptors not effective against DOM-based XSS\n\nThe third problem with this is that it is not effective against DOM-based XSS. To do that, one would have to have an interceptor or filter scan all the JavaScript content going as part of an HTTP response, try to figure out the tainted output and see if it it is susceptible to DOM-based XSS. That simply is not practical.\n\n#### Problem 4 - Interceptors not effective where data from responses originates outside your application\n\nThe last problem with interceptors is that they generally are oblivious to data in your application's responses that originate from other internal sources such as an internal REST-based web service or even an internal database. The problem is that unless your application is strictly validating that data _at the point that it is retrieved_ (which generally is the only point your application has enough context to do a strict data validation using an allow-list approach), that data should always be considered tainted. But if you are attempting to do output encoding or strict data validation all of tainted data on the HTTP response side of an interceptor (such as a Java servlet filter), at that point, your application's interceptor will have no idea of there is tainted data present from those REST web services or other databases that you used. The approach that generally is used on response-side interceptors attempting to provide XSS defense has been to only consider the matching \"input parameters\" as tainted and do output encoding or HTML sanitization on them and everything else is considered safe. But sometimes it's not? While it frequently is assumed that all internal web services and all internal databases can be \"trusted\" and used as it, this is a very bad assumption to make unless you have included that in some deep threat modeling for your application.\n\nFor example, suppose you are working on an application to show a customer their detailed monthly bill. Let's assume that your application is either querying a foreign (as in not part of your specific application) internal database or REST web service that your application uses to obtain the user's full name, address, etc. But that data originates from another application which you are assuming is \"trusted\" but actually has an unreported persistent XSS vulnerability on the various customer address-related fields. Furthermore, let's assume that you company's customer support staff can examine a customer's detailed bill to assist them when customers have questions about their bills. So nefarious customer decides to plant an XSS bomb in the address field and then calls customer service for assistance with the bill. Should a scenario like that ever play out, an interceptor attempting to prevent XSS is going to miss that completely and the result is going to be something much worse than just popping an alert box to display \"1\" or \"XSS\" or \"pwn'd\".\n\n### Summary\n\nOne final note: If deploying interceptors / filters as an XSS defense was a useful approach against XSS attacks, don't you think that it would be incorporated into all commercial Web Application Firewalls (WAFs) and be an approach that OWASP recommends in this cheat sheet?\n\n## Related Articles\n\n**XSS Attack Cheat Sheet:**\n\nThe following article describes how attackers can exploit different kinds of XSS vulnerabilities (and this article was created to help you avoid them):\n\n- OWASP: [XSS Filter Evasion Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/XSS_Filter_Evasion_Cheat_Sheet.html).\n\n**Description of XSS Vulnerabilities:**\n\n- OWASP article on [XSS](https://owasp.org/www-community/attacks/xss/) Vulnerabilities.\n\n**Discussion about the Types of XSS Vulnerabilities:**\n\n- [Types of Cross-Site Scripting](https://owasp.org/www-community/Types_of_Cross-Site_Scripting).\n\n**How to Review Code for Cross-Site Scripting Vulnerabilities:**\n\n- [OWASP Code Review Guide](https://owasp.org/www-project-code-review-guide/) article on [Reviewing Code for Cross-site scripting](https://wiki.owasp.org/index.php/Reviewing_Code_for_Cross-site_scripting) Vulnerabilities.\n\n**How to Test for Cross-Site Scripting Vulnerabilities:**\n\n- [OWASP Testing Guide](https://owasp.org/www-project-web-security-testing-guide/) article on testing for Cross-Site Scripting vulnerabilities.\n- [XSS Experimental Minimal Encoding Rules](https://wiki.owasp.org/index.php/XSS_Experimental_Minimal_Encoding_Rules) Provides examples and guidelines for experimental minimal encoding strategies to prevent Cross-Site Scripting (XSS) attacks.\n",
    "source": "https://raw.githubusercontent.com/OWASP/CheatSheetSeries/master/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.md"
  },
  {
    "content": "# SQL Injection Prevention Cheat Sheet\n\n## Introduction\n\nThis cheat sheet will help you prevent SQL injection flaws in your applications. It will define what SQL injection is, explain where those flaws occur, and provide four options for defending against SQL injection attacks. [SQL Injection](https://owasp.org/www-community/attacks/SQL_Injection) attacks are common because:\n\n1. SQL Injection vulnerabilities are very common, and\n2. The application's database is a frequent target for attackers because it typically contains interesting/critical data.\n\n## What Is a SQL Injection Attack?\n\nAttackers can use SQL injection on an application if it has dynamic database queries that use string concatenation and user supplied input. To avoid SQL injection flaws, developers need to:\n\n1. Stop writing dynamic queries with string concatenation or\n2. Prevent malicious SQL input from being included in executed queries.\n\nThere are simple techniques for preventing SQL injection vulnerabilities and they can be used with practically any kind of programming language and any type of database. While XML databases can have similar problems (e.g., XPath and XQuery injection), these techniques can be used to protect them as well.\n\n## Anatomy of A Typical SQL Injection Vulnerability\n\nA common SQL injection flaw in Java is below. Because its unvalidated \"customerName\" parameter is simply appended to the query, an attacker can enter SQL code into that query and the application would take the attacker's code and execute it on the database.\n\n```java\nString\u00a0query\u00a0=\u00a0\"SELECT\u00a0account_balance\u00a0FROM\u00a0user_data\u00a0WHERE\u00a0user_name\u00a0=\u00a0\"\n             +\u00a0request.getParameter(\"customerName\");\ntry\u00a0{\n    Statement\u00a0statement\u00a0=\u00a0connection.createStatement(\u00a0...\u00a0);\n    ResultSet\u00a0results\u00a0=\u00a0statement.executeQuery(\u00a0query\u00a0);\n}\n\n...\n```\n\n## Primary Defenses\n\n- **Option 1: Use of Prepared Statements (with Parameterized Queries)**\n- **Option 2: Use of Properly Constructed Stored Procedures**\n- **Option 3: Allow-list Input Validation**\n- **Option 4: STRONGLY DISCOURAGED: Escaping All User Supplied Input**\n\n### Defense Option 1: Prepared Statements (with Parameterized Queries)\n\nWhen developers are taught how to write database queries, they should be told to use prepared statements with variable binding (aka parameterized queries). Prepared statements are simple to write and easier to understand than dynamic queries, and parameterized queries force the developer to define all SQL code first and pass in each parameter to the query later.\n\nIf database queries use this coding style, the database will always distinguish between code and data, regardless of what user input is supplied. Also, prepared statements ensure that an attacker cannot change the intent of a query, even if SQL commands are inserted by an attacker.\n\n#### Safe Java Prepared Statement Example\n\nIn the safe Java example below, if an attacker were to enter the userID as `tom' or '1'='1`, the parameterized query would look for a username that literally matches the entire string `tom' or '1'='1`. Thus, the database would be protected against injections of malicious SQL code.\n\nThe following code example uses a `PreparedStatement`, Java's implementation of a parameterized query, to execute the same database query.\n\n```java\n//\u00a0This\u00a0should\u00a0REALLY\u00a0be\u00a0validated\u00a0too\nString\u00a0custname\u00a0=\u00a0request.getParameter(\"customerName\");\n//\u00a0Perform\u00a0input\u00a0validation\u00a0to\u00a0detect\u00a0attacks\nString\u00a0query\u00a0=\u00a0\"SELECT\u00a0account_balance\u00a0FROM\u00a0user_data\u00a0WHERE\u00a0user_name\u00a0=\u00a0?\u00a0\";\nPreparedStatement pstmt = connection.prepareStatement( query );\npstmt.setString(\u00a01,\u00a0custname);\nResultSet\u00a0results\u00a0=\u00a0pstmt.executeQuery(\u00a0);\n```\n\n#### Safe C\\# .NET Prepared Statement Example\n\nIn .NET, the creation and execution of the query doesn't change. Just pass the parameters to the query using the `Parameters.Add()` call as shown below.\n\n```csharp\nString\u00a0query\u00a0=\u00a0\"SELECT\u00a0account_balance\u00a0FROM\u00a0user_data\u00a0WHERE\u00a0user_name\u00a0=\u00a0?\";\ntry\u00a0{\n\u00a0\u00a0OleDbCommand\u00a0command\u00a0=\u00a0new\u00a0OleDbCommand(query,\u00a0connection);\n\u00a0\u00a0command.Parameters.Add(new OleDbParameter(\"customerName\", CustomerName Name.Text));\n\u00a0\u00a0OleDbDataReader\u00a0reader\u00a0=\u00a0command.ExecuteReader();\n\u00a0\u00a0//\u00a0\u2026\n}\u00a0catch\u00a0(OleDbException\u00a0se)\u00a0{\n\u00a0\u00a0//\u00a0error\u00a0handling\n}\n```\n\nWhile we have shown examples in Java and .NET, practically all other languages (including Cold Fusion and Classic ASP) support parameterized query interfaces. Even SQL abstraction layers, like the [Hibernate Query Language](http://hibernate.org/) (HQL) with the same type of injection problems (called [HQL Injection](http://cwe.mitre.org/data/definitions/564.html))  support parameterized queries as well:\n\n#### Hibernate Query Language (HQL) Prepared Statement (Named Parameters) Example\n\n```java\n// This\u00a0is\u00a0an\u00a0unsafe\u00a0HQL\u00a0statement\nQuery\u00a0unsafeHQLQuery\u00a0=\u00a0session.createQuery(\"from\u00a0Inventory\u00a0where\u00a0productID='\"+userSuppliedParameter+\"'\");\n// Here\u00a0is\u00a0a\u00a0safe\u00a0version\u00a0of\u00a0the\u00a0same\u00a0query\u00a0using\u00a0named\u00a0parameters\nQuery\u00a0safeHQLQuery\u00a0=\u00a0session.createQuery(\"from\u00a0Inventory\u00a0where\u00a0productID=:productid\");\nsafeHQLQuery.setParameter(\"productid\",\u00a0userSuppliedParameter);\n```\n\n#### Other Examples of Safe Prepared Statements\n\nIf you need examples of prepared queries/parameterized languages, including Ruby, PHP, Cold Fusion, Perl, and Rust, see the [Query Parameterization Cheat Sheet](Query_Parameterization_Cheat_Sheet.md) or this [site](http://bobby-tables.com/).\n\nGenerally, developers like prepared statements because all the SQL code stays within the application, which makes applications relatively database independent.\n\n### Defense Option 2: Stored Procedures\n\nThough stored procedures are not always safe from SQL injection, developers can use certain standard stored procedure programming constructs. This approach has the same effect as using parameterized queries, as long as the stored procedures are implemented safely (which is the norm for most stored procedure languages).\n\n#### Safe Approach to Stored Procedures\n\nIf stored procedures are needed, the safest approach to using them requires the developer to build SQL statements with parameters that are automatically parameterized, unless the developer does something largely out of the norm. The difference between prepared statements and stored procedures is that the SQL code for a stored procedure is defined and stored in the database itself, then called from the application. Since prepared statements and safe stored procedures are equally effective in preventing SQL injection, your organization should choose the approach that makes the most sense for you.\n\n#### When Stored Procedures Can Increase Risk\n\nOccasionally, stored procedures can increase risk when a system is attacked. For example, on MS SQL Server, you have three main default roles: `db_datareader`, `db_datawriter` and `db_owner`. Before stored procedures came into use, DBAs would give `db_datareader` or `db_datawriter` rights to the webservice's user, depending on the requirements.\n\nHowever, stored procedures require execute rights, a role not available by default. In some setups where user management has been centralized, but is limited to those 3 roles, web apps would have to run as `db_owner` so stored procedures could work. Naturally, that means that if a server is breached, the attacker has full rights to the database, where previously, they might only have had read-access.\n\n#### Safe Java Stored Procedure Example\n\nThe following code example uses Java's implementation of the stored procedure interface (`CallableStatement`) to execute the same database query. The `sp_getAccountBalance` stored procedure has to be predefined in the database and use the same functionality as the query above.\n\n```java\n//\u00a0This\u00a0should\u00a0REALLY\u00a0be\u00a0validated\nString\u00a0custname\u00a0=\u00a0request.getParameter(\"customerName\");\ntry\u00a0{\n\u00a0\u00a0CallableStatement cs = connection.prepareCall(\"{call sp_getAccountBalance(?)}\");\n\u00a0\u00a0cs.setString(1, custname);\n\u00a0\u00a0ResultSet\u00a0results\u00a0=\u00a0cs.executeQuery();\n\u00a0\u00a0//\u00a0\u2026\u00a0result\u00a0set\u00a0handling\n}\u00a0catch\u00a0(SQLException\u00a0se)\u00a0{\n\u00a0\u00a0//\u00a0\u2026\u00a0logging\u00a0and\u00a0error\u00a0handling\n}\n```\n\n#### Safe VB .NET Stored Procedure Example\n\nThe following code example uses a `SqlCommand`, .NET's implementation of the stored procedure interface, to execute the same database query. The `sp_getAccountBalance` stored procedure must be predefined in the database and use the same functionality as the query defined above.\n\n```vbnet\n\u00a0Try\n\u00a0\u00a0\u00a0Dim\u00a0command\u00a0As\u00a0SqlCommand\u00a0=\u00a0new\u00a0SqlCommand(\"sp_getAccountBalance\",\u00a0connection)\n\u00a0\u00a0\u00a0command.CommandType = CommandType.StoredProcedure\n\u00a0\u00a0\u00a0command.Parameters.Add(new SqlParameter(\"@CustomerName\", CustomerName.Text))\n\u00a0\u00a0\u00a0Dim\u00a0reader\u00a0As\u00a0SqlDataReader\u00a0=\u00a0command.ExecuteReader()\n\u00a0\u00a0\u00a0'...\n\u00a0Catch\u00a0se\u00a0As\u00a0SqlException\n\u00a0\u00a0\u00a0'error\u00a0handling\n\u00a0End\u00a0Try\n```\n\n### Defense Option 3: Allow-list Input Validation\n\nIf you are faced with parts of SQL queries that can't use bind variables, such as table names, column names, or sort order indicators (ASC or DESC), input validation or query redesign is the most appropriate defense. When table or column names are needed, ideally those values come from the code and not from user parameters.\n\n#### Sample Of Safe Table Name Validation\n\nWARNING: Using user parameter values to target table or column names is a symptom of poor design and a full rewrite should be considered if time allows. If that is not possible, developers should map the parameter values to the legal/expected table or column names to make sure unvalidated user input doesn't end up in the query.\n\nIn the example below, since `tableName` is identified as one of the legal and expected values for a table name in this query, it can be directly appended to the SQL query. Keep in mind that generic table validation functions can lead to data loss if table names are used in queries where they are not expected.\n\n```text\nString\u00a0tableName;\nswitch(PARAM):\n\u00a0\u00a0case\u00a0\"Value1\":\u00a0tableName\u00a0=\u00a0\"fooTable\";\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break;\n\u00a0\u00a0case\u00a0\"Value2\":\u00a0tableName\u00a0=\u00a0\"barTable\";\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break;\n\u00a0\u00a0...\n \u00a0default\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0:\u00a0throw\u00a0new\u00a0InputValidationException(\"unexpected\u00a0value\u00a0provided\"\n                                                  + \" for\u00a0table\u00a0name\");\n```\n\n#### Safest Use Of Dynamic SQL Generation (DISCOURAGED)\n\nWhen we say a stored procedure is \"implemented safely,\" that means it does not include any unsafe dynamic SQL generation. Developers do not usually generate dynamic SQL inside stored procedures. However, it can be done, but should be avoided.\n\nIf it can't be avoided, the stored procedure must use input validation or proper escaping, as described in this article, to make sure that all user supplied input to the stored procedure can't be used to inject SQL code into the dynamically generated query. Auditors should always look for uses of `sp_execute`, `execute` or `exec` within SQL Server stored procedures. Similar audit guidelines are necessary for similar functions for other vendors.\n\n#### Sample of Safer Dynamic Query Generation (DISCOURAGED)\n\nFor something simple like a sort order, it is best if the user supplied input is converted to a boolean, and then that boolean is used to select the safe value to append to the query. This is a very standard need in dynamic query creation.\n\nFor example:\n\n```java\npublic\u00a0String\u00a0someMethod(boolean\u00a0sortOrder)\u00a0{\n\u00a0String\u00a0SQLquery\u00a0=\u00a0\"some\u00a0SQL\u00a0...\u00a0order\u00a0by\u00a0Salary\u00a0\"\u00a0+\u00a0(sortOrder\u00a0?\u00a0\"ASC\"\u00a0:\u00a0\"DESC\");`\n\u00a0...\n```\n\nAny time user input can be converted to a non-String, like a date, numeric, boolean, enumerated type, etc. before it is appended to a query, or used to select a value to append to the query, this ensures it is safe to do so.\n\nInput validation is also recommended as a secondary defense in ALL cases, even when using bind variables as discussed earlier in this article. More techniques on how to implement strong input validation is described in the [Input Validation Cheat Sheet](Input_Validation_Cheat_Sheet.md).\n\n### Defense Option 4: STRONGLY DISCOURAGED: Escaping All User-Supplied Input\n\nIn this approach, the developer will escape all user input before putting it in a query. It is very database specific in its implementation.  This methodology is frail compared to other defenses, and we CANNOT guarantee that this option will prevent all SQL injections in all situations.\n\nIf an application is built from scratch or requires low risk tolerance, it should be built or re-written using parameterized queries, stored procedures, or some kind of Object Relational Mapper (ORM) that builds your queries for you.\n\n## Additional Defenses\n\nBeyond adopting one of the four primary defenses, we also recommend adopting all of these additional defenses to provide defense in depth. These additional defenses are:\n\n- **Least Privilege**\n- **Allow-list Input Validation**\n\n### Least Privilege\n\nTo minimize the potential damage of a successful SQL injection attack, you should minimize the privileges assigned to every database account in your environment. Start from the ground up to determine what access rights your application accounts require, rather than trying to figure out what access rights you need to take away.\n\nMake sure that accounts that only need read access are only granted read access to the tables they need access to. DO NOT ASSIGN DBA OR ADMIN TYPE ACCESS TO YOUR APPLICATION ACCOUNTS. We understand that this is easy, and everything just \"works\" when you do it this way, but it is very dangerous.\n\n#### Minimizing Application and OS Privileges\n\nSQL injection is not the only threat to your database data. Attackers can simply change the parameter values from one of the legal values they are presented with, to a value that is unauthorized for them, but the application itself might be authorized to access. As such, minimizing the privileges granted to your application will reduce the likelihood of such unauthorized access attempts, even when an attacker is not trying to use SQL injection as part of their exploit.\n\nWhile you are at it, you should minimize the privileges of the operating system account that the DBMS runs under. Don't run your DBMS as root or system! Most DBMSs run out of the box with a very powerful system account. For example, MySQL runs as system on Windows by default! Change the DBMS's OS account to something more appropriate, with restricted privileges.\n\n#### Details Of Least Privilege When Developing\n\nIf an account only needs access to portions of a table, consider creating a view that limits access to that portion of the data and assigning the account access to the view instead of the underlying table. Rarely, if ever, grant create or delete access to database accounts.\n\nIf you adopt a policy where you use stored procedures everywhere, and don't allow application accounts to directly execute their own queries, then restrict those accounts to only be able to execute the stored procedures they need. Don't grant them any rights directly to the tables in the database.\n\n#### Least Admin Privileges For Multiple DBs\n\nThe designers of web applications should avoid using the same owner/admin account in the web applications to connect to the database. Different DB users should be used for different web applications.\n\nIn general, each separate web application that requires access to the database should have a designated database user account that the application will use to connect to the DB. That way, the designer of the application can have good granularity in the access control, thus reducing the privileges as much as possible. Each DB user will then have select access to only what it needs, and write-access as needed.\n\nAs an example, a login page requires read access to the username and password fields of a table, but no write access of any form (no insert, update, or delete). However, the sign-up page certainly requires insert privilege to that table; this restriction can only be enforced if these web apps use different DB users to connect to the database.\n\n#### Enhancing Least Privilege with SQL Views\n\nYou can use SQL views to further increase the granularity of access by limiting the read access to specific fields of a table or joins of tables. It could have additional benefits.\n\nFor example, if the system is required (perhaps due to some specific legal requirements) to store the passwords of the users, instead of salted-hashed passwords, the designer could use views to compensate for this limitation. They could revoke all access to the table (from all DB users except the owner/admin) and create a view that outputs the hash of the password field and not the field itself.\n\nAny SQL injection attack that succeeds in stealing DB information will be restricted to stealing the hash of the passwords (could even be a keyed hash), since no DB user for any of the web applications has access to the table itself.\n\n### Allow-list Input Validation\n\nIn addition to being a primary defense when nothing else is possible (e.g., when a bind variable isn't legal), input validation can also be a secondary defense used to detect unauthorized input before it is passed to the SQL query. For more information please see the [Input Validation Cheat Sheet](Input_Validation_Cheat_Sheet.md). Proceed with caution here. Validated data is not necessarily safe to insert into SQL queries via string building.\n\n## Related Articles\n\n**SQL Injection Attack Cheat Sheets**:\n\nThe following articles describe how to exploit different kinds of SQL injection vulnerabilities on various platforms (that this article was created to help you avoid):\n\n- [SQL Injection Cheat Sheet](https://www.netsparker.com/blog/web-security/sql-injection-cheat-sheet/)\n- Bypassing WAF's with SQLi - [SQL Injection Bypassing WAF](https://owasp.org/www-community/attacks/SQL_Injection_Bypassing_WAF)\n\n**Description of SQL Injection Vulnerabilities**:\n\n- OWASP article on [SQL Injection](https://owasp.org/www-community/attacks/SQL_Injection) Vulnerabilities\n- OWASP article on [Blind_SQL_Injection](https://owasp.org/www-community/attacks/Blind_SQL_Injection) Vulnerabilities\n\n**How to Avoid SQL Injection Vulnerabilities**:\n\n- [OWASP Developers Guide](https://github.com/OWASP/DevGuide) article on how to avoid SQL injection vulnerabilities\n- OWASP Cheat Sheet that provides [numerous language specific examples of parameterized queries using both Prepared Statements and Stored Procedures](Query_Parameterization_Cheat_Sheet.md)\n- [The Bobby Tables site (inspired by the XKCD webcomic) has numerous examples in different languages of parameterized Prepared Statements and Stored Procedures](http://bobby-tables.com/)\n\n**How to Review Code for SQL Injection Vulnerabilities**:\n\n- [OWASP Code Review Guide](https://wiki.owasp.org/index.php/Category:OWASP_Code_Review_Project) article on how to [Review Code for SQL Injection](https://wiki.owasp.org/index.php/Reviewing_Code_for_SQL_Injection) Vulnerabilities\n\n**How to Test for SQL Injection Vulnerabilities**:\n\n- [OWASP Testing Guide](https://owasp.org/www-project-web-security-testing-guide) article on how to [Test for SQL Injection](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/07-Input_Validation_Testing/05-Testing_for_SQL_Injection.html) Vulnerabilities\n",
    "source": "https://raw.githubusercontent.com/OWASP/CheatSheetSeries/master/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.md"
  }
]